package com.le.ac.project.tool;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import weka.classifiers.Classifier;
import weka.classifiers.evaluation.Evaluation;
import weka.classifiers.evaluation.NominalPrediction;
import weka.classifiers.evaluation.Prediction;
import weka.classifiers.evaluation.output.prediction.AbstractOutput;
import weka.classifiers.functions.Logistic;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.converters.LibSVMLoader;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.NumericToNominal;
import weka.filters.unsupervised.attribute.Remove;

public class Predictor {

	/**
	 * read the arff file, convert it to Instances, which can be read by the
	 * java API
	 * 
	 * @param arffPath
	 *            path of the .arff dataset
	 * @param classNum
	 *            the column number of attribute as a class, -1 refers to if
	 *            class is the last column
	 * @return
	 * @throws IOException
	 * @author Lin
	 */
	public Instances readArff(String arffPath, Integer classNum) throws IOException {
		// read file by path
		BufferedReader reader = new BufferedReader(new FileReader(arffPath));
		Instances data = new Instances(reader);
		reader.close();
		// set the column number of attribute as class,
		if (classNum == -1) {
			data.setClassIndex(data.numAttributes() - 1);
		} else {
			data.setClassIndex(classNum - 1);
		}
		// testing
		// System.out.println(data.toString());
		return data;
	}

	/**
	 * convert numeric to nominal
	 * 
	 * @param data
	 *            Instances that is generated by .arff dataset
	 * @param columnNum
	 *            the no. of column/attribute that need to be converted, -1
	 *            refers to the last column/attributes
	 * @return converted Instances
	 * @author Lin
	 * @throws Exception
	 */
	public Instances num2nom(Instances data, Integer columnNum) throws Exception {
		NumericToNominal converter = new NumericToNominal();
		String[] options = new String[2];
		// set filter attributes
		options[0] = "-R";
		// the no. of column/attribute that need to be converted
		if (columnNum == -1) {
			options[1] = String.valueOf(data.numAttributes());
		} else {
			options[1] = String.valueOf(columnNum);
		}
		converter.setOptions(options);
		converter.setInputFormat(data);
		Instances convertedData = Filter.useFilter(data, converter);
		// ------------- test -----------
		// System.out.println("Before");
		// for (int i = 0; i < trainData.numAttributes(); i = i + 1) {
		// System.out.println("Nominal? " + trainData.attribute(i).isNominal());
		// }
		//
		// System.out.println("After");
		// for (int i = 0; i < trainData.numAttributes(); i = i + 1) {
		// System.out.println("Nominal? " +
		// convertedData.attribute(i).isNominal());
		// }
		// ------------ end test --------------
		return convertedData;
	}

	/**
	 * 
	 * @param removeAttsNum
	 * @param data
	 * @return new object of Instances, that the specified attribute have
	 *         already removed
	 * @throws Exception
	 * @author Lin
	 */
	public Instances removeAtts(List<Integer> removeAttsNum, Instances data) throws Exception {
		String[] removeOptions = new String[2];
		removeOptions[0] = "-R";
		// the remove string format should be "2,8", means remove 2nd and 8th
		// column of attributes
		String str = "";
		for (int i = 0; i < removeAttsNum.size(); i++) {
			if (str.equals("")) {
				str = str + String.valueOf(removeAttsNum.get(i));
			} else {
				str = str + "," + String.valueOf(removeAttsNum.get(i));
			}
		}
		removeOptions[1] = str;
		Remove remove = new Remove();
		remove.setOptions(removeOptions);
		remove.setInputFormat(data);
		Instances newData = Filter.useFilter(data, remove);
		return newData;
	}

	/**
	 * construct the logistic classifier
	 * 
	 * @param trainData
	 *            data used to train
	 * @return
	 * @throws Exception
	 * @author Lin
	 */
	public Logistic buildLogisticClassifier(Instances trainData) throws Exception {
		Logistic logisticClassifier = new Logistic();
		// set logistic classifier options
		String[] options = new String[6];
		options[0] = "-R";
		options[1] = "1E-8";
		options[2] = "-M";
		options[3] = "-1";
		options[4] = "-num-decimal-places";
		options[5] = "4";
		logisticClassifier.setOptions(options);
		// train the model by dataset
		logisticClassifier.buildClassifier(trainData);
		return logisticClassifier;
	}

	/**
	 * evaluate the logistic model. Confusion Matrix, acutal, predicted,
	 * probability of the prediction can be calculate in this method
	 * 
	 * @param classifier
	 * @param data
	 * @param testOption
	 *            The test function: 0 refers to use training set; 1 refers to
	 *            use cross validation;
	 * @return a list of prediction objects. Usage Example: in Logistic
	 *         Classifier, we can change the type of Prediction to
	 *         NominalPrediction, then invoke acutal(), predicted(),
	 *         distribution() method to get the actual/predicted/probability
	 *         value.
	 * @throws Exception
	 * @author Lin
	 */
	public Evaluation evalClassifier(Classifier classifier, Instances trainData, Integer testOption) throws Exception {
		// construct evaluator
		Evaluation eval = new Evaluation(trainData);
		if (testOption == 0) {
			// use data instances to evaluate the model
			eval.evaluateModel(classifier, trainData);
		} else if (testOption == 1) {
			// use cross-validation to evaluate the model
			eval.crossValidateModel(classifier, trainData, 10, new Random(1));
		}
		System.out.println("Logistic Regression on Evaluating Inflammation of urinary bladder");
		// Confusion Matrix
		System.out.println(eval.toMatrixString("=== Confusion Matrix ===\n"));

		return eval;
	}

	public Evaluation evalSuppliedSet(Classifier classifier, Instances trainData, Instances suppliedData)
			throws Exception {
		// construct evaluator
		Evaluation eval = new Evaluation(trainData);
		// use data instances to evaluate the model
		Object[] forPredictingPrinting = new Object[suppliedData.numInstances()];
		eval.evaluateModel(classifier, suppliedData,forPredictingPrinting);
		AbstractOutput abstractOutput = (AbstractOutput)forPredictingPrinting[0];

		return eval;
	}

	/**
	 * get the predictions by an evaluation
	 * 
	 * @param eval
	 *            evaluation of a model and the test cases
	 * @return
	 * @author Lin
	 */
	public List<Prediction> predictByEval(Evaluation eval) {
		List<Prediction> predictions = new ArrayList<Prediction>();
		predictions = eval.predictions();
		return predictions;
	}

	/**
	 * print the list of predictions, including the actual/predicted/probability
	 * value of each instance. Also, this function is an example of using the
	 * Prediction.
	 * 
	 * @param predictions
	 *            the list of Prediction objects
	 * @author Lin
	 */
	public void printPredictions(List<Prediction> predictions) {
		for (Prediction pct : predictions) {
			NominalPrediction np = (NominalPrediction) pct;
			double[] a = np.distribution();

			if (np.predicted() == 0) {
				// if the algorithm predict the value would be 0, get the
				// probability of 0
				System.out.println(/* "actual: " + np.actual() + ", "+ */"predicted: " + np.predicted()
						+ ", probability: " + a[0]);
			} else {
				// if the algorithm predict the value would be 1, get the
				// probability of 1
				System.out.println(/* "actual: " + np.actual() + ", "+ */"predicted: " + np.predicted()
						+ ", probability: " + a[1]);
			}
		}
	}

	/**
	 * an alternative way the get the prediction and distribution
	 * 
	 * @param model
	 * @param testData
	 * @throws Exception
	 * @author Lin
	 */
	public void predictTest(Classifier classifier, Instances testData) throws Exception {
		for (int i = 0; i < testData.numInstances(); i++) {
			double pred = classifier.classifyInstance(testData.instance(i));
			double[] result = classifier.distributionForInstance(testData.instance(0));
//			System.out.print("ID: " + i/* testData.instance(i).value(0) */);
//			System.out.print(", actual: " + testData.classAttribute().value((int) testData.instance(i).classValue()));
//			System.out.println(", predicted: " + testData.classAttribute().value((int) pred));
			System.out.println(pred+result.toString());
		}
	}

	/**
	 * Calculte prediction by logistic regression
	 * 
	 * @param trainingDataPath
	 *            the path of .arff file of the training data set, which used to
	 *            train the model
	 * @param pctDataPath
	 *            the path of data set that used to predict, .arff file required
	 * @param removeAttsNums
	 *            a list of number that represent the numbers of attribute
	 *            cloumn that need to be deleted
	 * @param classNum
	 *            set the number of attribute column as class
	 * @return a list of prediction objects. Take logistic as example, we can
	 *         change the type of Prediction to NominalPrediction, then invoke
	 *         acutal(), predicted(), distribution() method to get the
	 *         actual/predicted/probability value.
	 * @throws Exception
	 * @author Lin
	 */
	public List<Prediction> calPctByLogistic(String trainArffPath, String pctArffPath, List<Integer> removeAttsNums,
			Integer classNum) throws Exception {
		Predictor predictor = new Predictor();
		// String arffPath =
		// "/Users/Bingxiong/Desktop/finalProject/dataset/arff_files/credit_scores.arff";
		Instances data = predictor.readArff(trainArffPath, classNum);
		Instances suppliedData = predictor.readArff(pctArffPath, classNum);
		// change the class attribute from numeric to nominal
		Instances newData = predictor.num2nom(data, classNum);
		Instances newSuppliedData = predictor.num2nom(suppliedData, classNum);
		// delete attributes
		if (removeAttsNums.size() != 0 || removeAttsNums != null) {
			newData = removeAtts(removeAttsNums, newData);
			newSuppliedData = removeAtts(removeAttsNums, newSuppliedData);
		}
		Logistic logisticModel = predictor.buildLogisticClassifier(newData);
		
		
		//-------------test
//		predictTest(logisticModel, newSuppliedData);
		//---------------
		Evaluation eval = predictor.evalSuppliedSet(logisticModel, newData, newSuppliedData);
		List<Prediction> predictions = predictor.predictByEval(eval);
		// predictor.predict(logisticModel, newData);

		return predictions;
	}
	
	/**
	 * Calculte prediction by logistic regression, the last attribute column as the class
	 * 
	 * @param trainingDataPath
	 *            the path of .arff file of the training data set, which used to
	 *            train the model
	 * @param pctDataPath
	 *            the path of data set that used to predict, .arff file required
	 * @param removeAttsNums
	 *            a list of number that represent the numbers of attribute
	 *            cloumn that need to be deleted
	 * @return a list of prediction objects. Take logistic as example, we can
	 *         change the type of Prediction to NominalPrediction, then invoke
	 *         acutal(), predicted(), distribution() method to get the
	 *         actual/predicted/probability value.
	 * @throws Exception
	 * @author Lin
	 */
	public List<Prediction> calPctByLogistic(String trainArffPath, String pctArffPath, List<Integer> removeAttsNums) throws Exception {
		return calPctByLogistic(trainArffPath, pctArffPath, removeAttsNums, -1);
	}

	public List<Prediction> calLogisticPctByCSV(String trainCSVPath, String pctCSVPath, String trainArffPath,
			String pctArffPath, List<Integer> removeAttsNums) throws Exception {
		Converters c = new Converters();
		c.convertCSV2Arff(trainCSVPath, trainArffPath);
		c.convertCSV2Arff(pctCSVPath, pctArffPath);
		return calPctByLogistic(trainArffPath, pctArffPath, removeAttsNums);
	}

	/**
	 * get the prediction and probability of the 1st element from the Prediction object
	 * @param predictions
	 * @return
	 * @author Lin
	 */
	public Double[] getPr(List<Prediction> predictions) {
		Prediction pct = predictions.get(0);
		NominalPrediction np = (NominalPrediction) pct;
		double[] a = np.distribution();
		Double[] pr = new Double[2];
		pr[0] = np.predicted();
		pr[1] = a[1];
				
		return pr;
	}

	
	
	public static void main(String[] args) {
		// test and usage
		Predictor predictor = new Predictor();
		String arffPath = "/Users/Bingxiong/Desktop/finalProject/dataset/arff_files/credit_scores.arff";
		String test1Path = "/Users/Bingxiong/Desktop/finalProject/dataset/test_predict/test1.csv";
		String test1Arff = "/Users/Bingxiong/Desktop/finalProject/dataset/test_predict/test1.arff";
		Converters ca = new Converters();
		try {
			ca.convertCSV2Arff(test1Path, test1Arff);
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		Instances data;
		Instances suppliedData;
		try {
			// data = predictor.readArff(arffPath, -1);
			// suppliedData = predictor.readArff(test1Arff, -1);
			// Instances newData = predictor.num2nom(data, 21);
			// Instances newSuppliedData = predictor.num2nom(suppliedData, 21);
			// Logistic logisticModel =
			// predictor.buildLogisticClassifier(newData);
			// System.out.println(logisticModel);
			// Evaluation evaluation = predictor.evalSuppliedSet(logisticModel,
			// newData, newSuppliedData);
			// List<Prediction> predictions =
			// predictor.predictByEval(evaluation);
			/*
			 * calPctByLogistic(path, path) can also be used if we only want to
			 * get the prediction list directly
			 */
			// removint 2nd and 8th attributes
			List<Integer> removeAttsNums = new ArrayList<>(Arrays.asList(2,8));
			List<Prediction> predictions = predictor.calPctByLogistic(arffPath, test1Arff, removeAttsNums);
			predictor.printPredictions(predictions);
			// System.out.println(evaluation.pctCorrect() + "% correct rate");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
